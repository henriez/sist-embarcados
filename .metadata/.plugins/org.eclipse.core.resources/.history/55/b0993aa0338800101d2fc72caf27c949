#include "display.h"

// ST7789 Commands
#define ST7789_SWRESET 0x01
#define ST7789_SLPOUT  0x11
#define ST7789_NORON   0x13
#define ST7789_INVOFF  0x20
#define ST7789_INVON   0x21
#define ST7789_DISPOFF 0x28
#define ST7789_DISPON  0x29
#define ST7789_CASET   0x2A
#define ST7789_RASET   0x2B
#define ST7789_RAMWR   0x2C
#define ST7789_MADCTL  0x36
#define ST7789_COLMOD  0x3A

// ST7789 Driver Defines
#define ST7789_WIDTH  240
#define ST7789_HEIGHT 240

#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) < (b) ? (a) : (b))


extern SPI_HandleTypeDef hspi2;

void display_writeCommand(uint8_t cmd) {
    HAL_GPIO_WritePin(Display_DC_GPIO_Port, Display_DC_Pin, 0);
    HAL_SPI_Transmit(&hspi2, &cmd, 1, HAL_MAX_DELAY);
}


void display_writeData(uint8_t* data, size_t len) {
    HAL_GPIO_WritePin(Display_DC_GPIO_Port, Display_DC_Pin, 1);
    HAL_SPI_Transmit(&hspi2, data, len, HAL_MAX_DELAY);
}


void display_reset(void) {
    HAL_GPIO_WritePin(Display_Res_GPIO_Port, Display_Res_Pin, 0);
    HAL_Delay(10);
    HAL_GPIO_WritePin(Display_Res_GPIO_Port, Display_Res_Pin, 1);
    HAL_Delay(100);
}


void display_setAddressWindow(uint16_t x0, uint16_t y0, uint16_t x1, uint16_t y1) {
    uint8_t data[4];

    // Column Address Set
    display_writeCommand(ST7789_CASET);
    data[0] = (x0 >> 8) & 0xFF;
    data[1] = x0 & 0xFF;
    data[2] = (x1 >> 8) & 0xFF;
    data[3] = x1 & 0xFF;
    display_writeData(data, 4);

    // Row Address Set
    display_writeCommand(ST7789_RASET);
    data[0] = (y0 >> 8) & 0xFF;
    data[1] = y0 & 0xFF;
    data[2] = (y1 >> 8) & 0xFF;
    data[3] = y1 & 0xFF;
    display_writeData(data, 4);

    // Write to RAM
    display_writeCommand(ST7789_RAMWR);
}


void display_init(void) {
	display_reset();

	display_writeCommand(ST7789_SWRESET); // 1: Software reset
    HAL_Delay(150);

    display_writeCommand(ST7789_SLPOUT); // 2: Out of sleep mode
    HAL_Delay(255);

    uint8_t data;
    data = 0x55; // 16 bits per pixel
    display_writeCommand(ST7789_COLMOD); // 3: Set color mode
    display_writeData(&data, 1);
    HAL_Delay(10);

    data = 0x00;
    display_writeCommand(ST7789_MADCTL); // 4: Memory access control
    display_writeData(&data, 1);

    display_writeCommand(ST7789_INVON); // 5: Invert display
    HAL_Delay(10);

    display_writeCommand(ST7789_NORON); // 6: Normal display on
    HAL_Delay(10);

    display_writeCommand(ST7789_DISPON); // 7: Main screen turn on
    HAL_Delay(255);
}


void display_fillScreen(uint16_t color) {
    display_setAddressWindow(0, 0, ST7789_WIDTH - 1, ST7789_HEIGHT - 1);

    uint8_t color_data[2] = {(color >> 8) & 0xFF, color & 0xFF};

    HAL_GPIO_WritePin(Display_DC_GPIO_Port, Display_DC_Pin, 1);

    for (uint32_t i = 0; i < ST7789_WIDTH * ST7789_HEIGHT; i++) {
        HAL_SPI_Transmit(&hspi2, color_data, 2, HAL_MAX_DELAY);
    }
}


void display_drawChar(uint16_t x, uint16_t y, char character, const Font* font, uint16_t foreground, uint16_t background) {
    if (character < font->min_character || character > font->max_character) {
        return;
    }
    if ((x + font->width > ST7789_WIDTH) || (y + font->height > ST7789_HEIGHT)) {
        return;
    }

    uint32_t offset = (character - font->min_character) * font->height;

    // character bounding box
    display_setAddressWindow(x, y, x + font->width - 1, y + font->height - 1);

    HAL_GPIO_WritePin(Display_DC_GPIO_Port, Display_DC_Pin, 1);

    for (uint16_t i = 0; i < font->height; i++) {
        for (uint16_t j = 0; j < font->width; j++) {
        	uint16_t bit = font->data[offset + i] & (0x8000 >> j);
        	uint16_t color = bit ? foreground : background;
        	uint8_t color_bytes[2] = { (color >> 8) & 0xFF, color & 0xFF };
            HAL_SPI_Transmit(&hspi2, color_bytes, 2, HAL_MAX_DELAY);
        }
    }
}


void display_drawBitmap(uint16_t x, uint16_t y, uint16_t w, uint16_t h, const uint8_t* data, uint16_t foreground, uint16_t background) {
    if (data == NULL || (x + w > ST7789_WIDTH) || (y + h > ST7789_HEIGHT)) {
        return;
    }

    display_setAddressWindow(x, y, x + w - 1, y + h - 1);

    uint8_t fg_color_bytes[2] = { (foreground >> 8) & 0xFF, foreground & 0xFF };
    uint8_t bg_color_bytes[2] = { (background >> 8) & 0xFF, background & 0xFF };

    HAL_GPIO_WritePin(Display_DC_GPIO_Port, Display_DC_Pin, 1);

    for (uint32_t i = 0; i < (w * h); i++) {
    	uint8_t bit = data[i];
    	uint8_t *color_bytes = bit ? &fg_color_bytes : &bg_color_bytes;
		HAL_SPI_Transmit(&hspi2, color_bytes, 2, HAL_MAX_DELAY);
    }
}


void display_writeString(uint16_t x, uint16_t y, const char* str, const Font* font, uint16_t foreground, uint16_t background) {
    if (font == NULL || str == NULL) {
        return;
    }

    uint16_t start_x = x;

    for (uint8_t i = 0; i < strlen(str); i++) {
        if (x + font->width > ST7789_WIDTH) {
        	 // virtual \n
            y += font->height;
            x = start_x;
        }

        display_drawChar(x, y, str[i], font, foreground, background);
        x += font->width;
    }
}


void display_drawCircle(uint16_t x, uint16_t y, uint16_t r, uint16_t foreground, uint16_t background){


}


